{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.2.0\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from '@iobroker/adapter-core';\n\nimport type { Device } from './lib/Device';\nimport { DeviceInfo } from './lib/DeviceInfo';\nimport { AutoDetector } from './lib/autoDetect';\nimport type { TableDevice } from './lib/TableDevice';\nimport { sanitizeTableDevice } from './lib/TableDevice';\nimport { createFromObject, createFromTable } from './lib/DeviceFactory';\n\n// Load your modules here, e.g.:\n// import * as fs from \"fs\";\n\nclass Mydlink extends utils.Adapter {\n    /**\n     * Array of devices.\n     * Device consists of:\n     * config: which includes IP, PIN, ... set by the user\n     * client: soapclient for interaction with device\n     *\n     */\n    devices: Array<Device> = [];\n\n    /**\n     * Auto-detected devices. Store here and aggregate until we are sure it is mydlink and have mac\n     * -> multiple messages.\n     *\n     */\n    autoDetector: AutoDetector | undefined = undefined;\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'mydlink',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('stateChange', this.onStateChange.bind(this));\n        this.on('message', this.onMessage.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n    }\n\n    /**\n     * deletes all objects of a device and the device itself (deleteDeviceAsync does not work somehow...?)\n     *\n     * @param device device to delete\n     */\n    async deleteDeviceFull(device: Device): Promise<void> {\n        //stop device:\n        device.stop();\n\n        //check if detected device:\n        if (this.autoDetector) {\n            for (const ip of Object.keys(this.autoDetector.detectedDevices)) {\n                const dectDevice = this.autoDetector.detectedDevices[ip];\n                if (dectDevice.mac === device.id) {\n                    dectDevice.alreadyPresent = false;\n                }\n            }\n        }\n\n        try {\n            const ids = await this.getObjectListAsync({\n                startkey: `${this.namespace}.${device.id}`,\n                endkey: `${this.namespace}.${device.id}\\u9999`,\n            });\n            if (ids) {\n                for (const obj of ids.rows) {\n                    await this.delObjectAsync(obj.value._id);\n                }\n            }\n        } catch (e: any) {\n            this.log.error(`Error during deletion of ${device.id}: ${e.stack}`);\n        }\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        // Initialize your adapter here\n\n        //get secret for decryption:\n        const systemConfig = await this.getForeignObjectAsync('system.config');\n        if (systemConfig) {\n            DeviceInfo.setSecret(systemConfig.native ? systemConfig.native.secret : 'RJaeBLRPwvPfh5O'); //fallback in case or for old installations without secret.\n        }\n\n        // Reset the connection indicator during startup\n        await this.delObjectAsync('info', { recursive: true });\n\n        //start auto detection:\n        this.autoDetector = new AutoDetector(this);\n\n        //start existing devices:\n        const existingDevices = await this.getDevicesAsync();\n        const configDevicesToAdd = [].concat(this.config.devices) as TableDevice[];\n        this.log.debug(`Got existing devices: ${JSON.stringify(existingDevices, null, 2)}`);\n        this.log.debug(`Got config devices: ${JSON.stringify(configDevicesToAdd, null, 2)}`);\n        let needUpdateConfig = false;\n        for (const existingDevice of existingDevices) {\n            let found = false;\n            for (const configDevice of this.config.devices as TableDevice[]) {\n                sanitizeTableDevice(configDevice);\n                needUpdateConfig = !configDevice.mac;\n                if (\n                    (configDevice.mac && configDevice.mac === existingDevice.native.mac) ||\n                    (!configDevice.mac && configDevice.ip === existingDevice.native.ip)\n                ) {\n                    found = true;\n\n                    //copy all data from config, because now only config is changed from config dialog.\n                    for (const key of Object.keys(configDevice)) {\n                        existingDevice.native[key] = configDevice[key]; //copy all fields.\n                    }\n                    existingDevice.native.pinNotEncrypted = !configDevice.mac;\n\n                    configDevicesToAdd.splice(configDevicesToAdd.indexOf(configDevice), 1);\n                    break; //break on first copy -> will remove additional copies later.\n                }\n            }\n            const device = await createFromObject(this, existingDevice);\n            if (device) {\n                await device.createDeviceObject(); //store new config.\n                if (existingDevice.native.pinNotEncrypted) {\n                    needUpdateConfig = true;\n                }\n                if (found) {\n                    await device.start();\n                    //keep config and client for later reference.\n                    this.devices.push(device);\n                } else {\n                    this.log.debug(`Deleting ${device.name}`);\n                    await this.deleteDeviceFull(device);\n                }\n            } else {\n                this.log.error(`Could not create device for existing device entry: ${existingDevice._id}`);\n            }\n        }\n\n        //add non-existing devices from config:\n        for (const configDevice of configDevicesToAdd) {\n            sanitizeTableDevice(configDevice);\n            const device = await createFromTable(this, configDevice, !configDevice.pinNotEncrypted);\n            if (device) {\n                this.log.debug(`Device ${device.name} in config but not in devices -> create and add.`);\n\n                const oldDevice = this.devices.find(d => d.mac === device.mac);\n                if (oldDevice) {\n                    this.log.info(\n                        `Duplicate entry for ${\n                            device.mac\n                        } in config. Trying to rectify. Restart will happen. Affected devices: ${device.name} === ${\n                            configDevice.name\n                        }`,\n                    );\n                    needUpdateConfig = true;\n                } else {\n                    //make sure objects are created:\n                    await device.createDeviceObject();\n\n                    await device.start();\n                    //call this here again, to make sure it happens.\n                    await device.createDeviceObject(); //store device settings\n                    //keep config and client for later reference.\n                    this.devices.push(device);\n                }\n            } else {\n                this.log.error(`Could not create device for config entry with IP: ${configDevice.ip}`);\n            }\n        }\n\n        //try to update config:\n        if (needUpdateConfig) {\n            const devices = [];\n            for (const device of this.devices) {\n                const configDevice = {\n                    ip: device.ip,\n                    mac: device.mac,\n                    pin: device.pinEncrypted,\n                    pollInterval: device.pollInterval,\n                    enabled: device.enabled,\n                    name: device.name,\n                    model: device.model,\n                    useWebSocket: device.isWebsocket,\n                };\n                devices.push(configDevice);\n            }\n            await this.extendForeignObjectAsync(`system.adapter.${this.namespace}`, {\n                native: {\n                    devices: devices,\n                },\n            });\n        }\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     *\n     * @param callback function to call when cleanup is done\n     */\n    private onUnload(callback: () => void): void {\n        try {\n            this.log.debug('Stop polling');\n            for (const device of this.devices) {\n                device.stop();\n            }\n            if (this.autoDetector) {\n                this.autoDetector.close();\n            }\n\n            this.log.info('cleaned everything up...');\n            callback();\n        } catch (e: any) {\n            this.log.error(`Error during unload: ${e}`);\n            callback();\n        }\n    }\n\n    /**\n     * Is called if a subscribed state changes\n     *\n     * @param id id of changed state object\n     * @param state changed state\n     */\n    private async onStateChange(id: string, state: ioBroker.State | null | undefined): Promise<void> {\n        if (state) {\n            //ignore delete state\n            // The state was changed\n            this.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n\n            //only act if ack = false.\n            if (!state.ack) {\n                const deviceId = id.split('.')[2]; //0 = adapter, 1 = instance -> 2 = device id.\n                const device = this.devices.find(d => d.id === deviceId);\n                if (device) {\n                    await device.handleStateChange(id, state);\n                } else {\n                    this.log.info(`Unknown device ${deviceId} for ${id}. Can't control anything.`);\n                }\n            }\n        }\n    }\n\n    /**\n     * Some message was sent to this instance over message box.\n     * Using this method requires \"common.messagebox\" property to be set to true in io-package.json\n     *\n     * @param obj the message object\n     */\n    private async onMessage(obj: ioBroker.Message): Promise<void> {\n        if (typeof obj === 'object' && obj.message) {\n            switch (obj.command) {\n                case 'discovery': {\n                    // Send response in callback if required\n                    if (obj.callback) {\n                        const devices = [];\n                        if (this.autoDetector) {\n                            for (const key of Object.keys(this.autoDetector.detectedDevices)) {\n                                const device = this.autoDetector.detectedDevices[key];\n                                device.readOnly = true;\n                                devices.push(device);\n                            }\n                        }\n                        this.sendTo(obj.from, obj.command, devices, obj.callback);\n                    }\n                    break;\n                }\n                case 'getDevices': {\n                    const tableDevices = [];\n                    for (const device of this.devices) {\n                        const tableDevice = {\n                            name: device.name,\n                            mac: device.mac,\n                            ip: device.ip,\n                            pin: device.pinDecrypted,\n                            pollInterval: device.pollInterval,\n                            enabled: device.enabled,\n                        };\n                        tableDevices.push(tableDevice);\n                    }\n                    if (obj.callback) {\n                        this.sendTo(obj.from, obj.command, tableDevices, obj.callback);\n                    }\n                    break;\n                }\n                case 'identifyDevice': {\n                    const params = obj.message as Record<string, any>;\n                    if (params && params.ip && params.pin) {\n                        let device = await createFromTable(\n                            this,\n                            {\n                                ip: params.ip,\n                                pin: params.pin,\n                            },\n                            false,\n                        );\n                        if (!device) {\n                            this.log.info('could not create device -> error.');\n                            if (obj.callback) {\n                                this.sendTo(obj.from, obj.command, 'ERROR', obj.callback);\n                            }\n                            return;\n                        }\n                        try {\n                            await device.start();\n                            if (device.loggedIn && device.identified) {\n                                //will be false if ip wrong or duplicate mac.\n                                const oldDevice = this.devices.find(d => d.mac === device?.mac);\n                                if (oldDevice) {\n                                    device.stop();\n                                    device = oldDevice;\n                                } else {\n                                    this.devices.push(device);\n                                }\n                                const sendDevice = {\n                                    mac: device.mac,\n                                    name: device.name,\n                                    ip: device.ip,\n                                    pollInterval: device.pollInterval,\n                                    pin: device.pinDecrypted,\n                                    enabled: device.loggedIn && device.identified,\n                                };\n                                if (obj.callback) {\n                                    this.sendTo(obj.from, obj.command, sendDevice, obj.callback);\n                                }\n                            } else {\n                                this.log.info('could not login -> error.');\n                                this.sendTo(obj.from, obj.command, 'ERROR', obj.callback);\n                            }\n                        } catch (e: any) {\n                            this.log.info(`could not login device: ${e.stack}`);\n                            if (obj.callback) {\n                                this.sendTo(obj.from, obj.command, 'ERROR', obj.callback);\n                            }\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    this.log.debug(`Unknown command ${obj.command}`);\n                    break;\n                }\n            }\n        }\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new Mydlink(options);\n} else {\n    // otherwise start the instance directly\n    (() => new Mydlink())();\n}\n"],
  "mappings": "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",
  "names": []
}
