{
  "version": 3,
  "sources": ["../../src/lib/autoDetect.ts"],
  "sourcesContent": ["/// <reference types=\"./mdns-discovery\" />\n\nimport type { Mydlink } from './mydlink';\nimport MulticastDNS from 'mdns-discovery';\n\nimport { WebSocketDevice } from './WebSocketDevice';\n\n/**\n * Auto-detection of devices via mDNS.\n */\nexport class AutoDetector {\n    mdns: MulticastDNS;\n\n    adapter: Mydlink;\n\n    detectedDevices: Record<string, any> = {};\n\n    debug = false;\n\n    /**\n     * Log debug message if debug is enabled.\n     *\n     * @param message The message to log.\n     */\n    logDebug(message: string): void {\n        if (this.debug) {\n            this.adapter.log.debug(message);\n        }\n    }\n\n    /**\n     * Handle detection entry from mDNS.\n     *\n     * @param entry The detection entry.\n     * @param entry.ip The IP address of the detected device.\n     * @param entry.type The type of the detected device.\n     * @param entry.name The name of the detected device.\n     * @param entry.mac The MAC address of the detected device, if available.\n     * @param entry.PTR The PTR record of the detected device, if available.\n     * @param entry.TXT The TXT record of the detected device, if available.\n     */\n    async onDetection(entry: {\n        ip: string;\n        type: string;\n        name: string;\n        mac: string | undefined;\n        PTR: Record<string, string | object> | undefined;\n        TXT: Record<string, string | object> | undefined;\n    }): Promise<void> {\n        //format of data: length-byte + text + length-byte + text + length-byte + text ...\n        function extractStringsFromBuffer(buffer: Buffer): string[] {\n            let index = 0;\n            const strings = [];\n            while (index < buffer.length) {\n                const length = buffer.readInt8(index);\n                index += 1;\n                strings.push(buffer.subarray(index, index + length).toString());\n                index += length;\n            }\n            return strings;\n        }\n\n        //somehow starts to detect fritzbox later on??\n        if (entry.name !== '_dhnap._tcp.local' && entry.name !== '_dcp._tcp.local') {\n            //this.log.debug('Ignoring false detection? -> ' + entry.ip + ' - ' + entry.name);\n            return;\n        }\n        if (entry.name === '_dcp._tcp.local') {\n            this.logDebug('Maybe detected websocket device');\n            console.log(entry);\n            //get model:\n            let model: string | undefined = undefined;\n            if (entry.PTR && entry.PTR.data && typeof entry.PTR.data === 'string') {\n                model = entry.PTR.data.substring(0, 8);\n            }\n\n            //somehow I get records for devices from wrong IP. or they report devices, they detect under their IP?? not sure...\n            //let's connect here and get the MAC -> so we can securely identify the device.\n            //then decide if it is a new one (update & present in UI) or an old one (ignore for now).\n            const newDevice = new WebSocketDevice(this.adapter, entry.ip, 'INVALID', false);\n            newDevice.model = model;\n\n            try {\n                await newDevice.client.login();\n                newDevice.id = newDevice.client.getDeviceId().toUpperCase();\n                if (newDevice.id) {\n                    newDevice.mac = newDevice.id.match(/.{2}/g).join(':');\n                    this.logDebug(`Got websocket device ${model} on ${newDevice.ip}`);\n                }\n            } catch (e: any) {\n                this.logDebug(`Could not identify websocket device: ${e.stack}`);\n            } finally {\n                newDevice.stop();\n            }\n\n            //now use mac to check if we already now that device:\n            const device = this.adapter.devices.find(device => device.mac === entry.mac);\n            if (device) {\n                this.logDebug(`Device was already present as ${device.model} on ${device.ip}`);\n                if (device.ip === newDevice.ip && device.model !== newDevice.model) {\n                    this.logDebug(`Model still differs? ${device.model} != ${newDevice.model}`);\n                    if (model && device.isWebsocket) {\n                        this.logDebug(`Updated model to ${model}`);\n                        device.model = model;\n                        await device.createDeviceObject(); //store new model in config.\n                    }\n                }\n            } else {\n                //not known yet, add to detected devices:\n                this.detectedDevices[entry.ip] = {\n                    ip: newDevice.ip,\n                    name: entry.name,\n                    type: model,\n                    mac: newDevice.mac,\n                    mydlink: true,\n                    useWebSocket: true,\n                    alreadyPresent: !!device,\n                };\n            }\n        }\n\n        //this.log.debug('Got discovery: ' + JSON.stringify(entry, null, 2));\n        if (entry.TXT && entry.TXT.data) {\n            //build detected device and fill it:\n            let device = this.detectedDevices[entry.ip];\n            if (!device) {\n                device = {\n                    ip: entry.ip,\n                    name: entry.name,\n                };\n            }\n\n            //parse buffer:\n            const keyValuePairs = extractStringsFromBuffer(entry.TXT.data as Buffer);\n            for (const pair of keyValuePairs) {\n                const [key, value] = pair.split('=');\n                switch (key.toLowerCase()) {\n                    //extract mac from buffer:\n                    case 'mac': {\n                        device.mac = value.toUpperCase();\n                        break;\n                    }\n                    //extract model number from buffer:\n                    case 'model_number': {\n                        device.type = value;\n                        break;\n                    }\n                    //if mydlink=true -> we should look at that device! :)\n                    case 'mydlink': {\n                        if (value === 'true') {\n                            device.mydlink = true; //ok, great :-)\n                        }\n                    }\n                }\n            }\n\n            if (device.mydlink) {\n                this.detectedDevices[device.ip] = device;\n                const oldDevice = this.adapter.devices.find(d => d.mac === device.mac);\n                if (oldDevice) {\n                    //update model, if differs.\n                    if (oldDevice.model !== device.type) {\n                        oldDevice.model = device.type;\n                    }\n                    //found device we already know. Let's check ip.\n                    if (device.ip !== oldDevice.ip) {\n                        oldDevice.ip = device.ip;\n                        await oldDevice.createDeviceObject(); //store IP in config.\n                        await oldDevice.start();\n                    }\n                    device.alreadyPresent = true;\n                }\n                this.logDebug(`Detected Device now is: ${JSON.stringify(device, null, 2)}`);\n            }\n        }\n    }\n\n    /**\n     * Close the mDNS listener.\n     */\n    close(): void {\n        if (this.mdns && typeof this.mdns.close === 'function') {\n            this.mdns.close();\n        }\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param adapter reference to the adapter\n     */\n    constructor(adapter: Mydlink) {\n        this.adapter = adapter;\n        this.mdns = new MulticastDNS({\n            timeout: 0, //0 == stay active??\n            name: ['_dhnap._tcp.local', '_dcp._tcp.local'],\n            find: '*',\n            broadcast: false,\n        });\n\n        this.logDebug('Auto detection started');\n        if (this.mdns !== undefined) {\n            this.mdns.on('entry', this.onDetection.bind(this));\n            this.mdns.run(() => adapter.log.info('Discovery done'));\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["device", "MulticastDNS"]
}
