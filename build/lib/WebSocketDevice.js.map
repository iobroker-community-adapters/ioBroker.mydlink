{
  "version": 3,
  "sources": ["../../src/lib/WebSocketDevice.ts"],
  "sourcesContent": ["import { Device, processNetworkError, WrongMacError, WrongModelError } from './Device';\nimport { Suffixes } from './suffixes';\nimport type { Mydlink } from './mydlink';\nimport { default as axios } from 'axios';\nimport WebSocketClient from 'dlink_websocketclient';\n\n/**\n * Class for WebSocket based devices, i.e. newer ones.\n */\nexport class WebSocketDevice extends Device {\n    client: WebSocketClient;\n\n    numSockets = 1;\n\n    /**\n     * Creates an instance of WebSocketDevice.\n     *\n     * @param adapter reference to adapter\n     * @param ip ip of device\n     * @param pin pin of device\n     * @param pinEncrypted is pin encrypted\n     */\n    constructor(adapter: Mydlink, ip: string, pin: string, pinEncrypted: boolean) {\n        super(adapter, ip, pin, pinEncrypted);\n        this.isWebsocket = true;\n\n        this.client = new WebSocketClient({\n            ip: this.ip,\n            pin: this.pinDecrypted,\n            keepAlive: 5,\n            useTelnetForToken: this.pinDecrypted?.toUpperCase() === 'TELNET',\n            log: console.debug,\n        });\n    }\n\n    /**\n     * Creates objects for the device.\n     */\n    async createObjects(): Promise<void> {\n        await super.createObjects();\n        if (this.numSockets > 1) {\n            //create state for each socket.\n            for (let index = 1; index <= this.numSockets; index += 1) {\n                const id = `${this.id + Suffixes.state}_${index}`;\n                await this.adapter.setObjectNotExistsAsync(id, {\n                    type: 'state',\n                    common: {\n                        name: `Socket ${index}`,\n                        type: 'boolean',\n                        role: 'switch',\n                        read: true,\n                        write: true,\n                    },\n                    native: { index: index },\n                });\n                await this.adapter.subscribeStatesAsync(id);\n            }\n        } else {\n            //create state object, for plug this is writable for sensor not.\n            await this.adapter.setObjectNotExistsAsync(this.id + Suffixes.state, {\n                type: 'state',\n                common: {\n                    name: 'state of plug',\n                    type: 'boolean',\n                    role: 'switch',\n                    read: true,\n                    write: true,\n                },\n                native: {},\n            });\n            await this.adapter.subscribeStatesAsync(this.id + Suffixes.state);\n        }\n    }\n\n    /**\n     * Stop communication and clean up.\n     */\n    stop(): void {\n        super.stop();\n        if (this.client && typeof this.client.removeAllListeners === 'function') {\n            this.client.removeAllListeners('switch');\n            this.client.removeAllListeners('error');\n            this.client.removeAllListeners('close');\n            this.client.removeAllListeners('message');\n        }\n    }\n\n    /**\n     * Do polling here.\n     *\n     * @returns void\n     */\n    async onInterval(): Promise<void> {\n        await super.onInterval();\n        // if not ready -> communication did fail, will be retried on next poll.\n        if (this.ready) {\n            try {\n                if (this.numSockets > 1) {\n                    const states = (await this.client.state(-1)) as Array<boolean>; //get all socket states.\n                    for (let index = 1; index <= this.numSockets; index += 1) {\n                        const id = `${this.id + Suffixes.state}_${index}`;\n                        const val = states[index - 1];\n                        await this.adapter.setStateChangedAsync(id, val, true);\n                    }\n                } else {\n                    const val = (await this.client.state(0)) as boolean;\n                    await this.adapter.setStateChangedAsync(this.id + Suffixes.state, val, true);\n                }\n            } catch (e) {\n                await this.handleNetworkError(e);\n            }\n        }\n    }\n\n    /**\n     * Error handler for event base client.\n     *\n     * @param code error code recieved\n     * @param err error object\n     */\n    async onError(code?: number, err?: Error): Promise<void> {\n        await this.adapter.setState(this.id + Suffixes.unreachable, true, true);\n        if (code || err) {\n            this.adapter.log.debug(`${this.name}: Socket error: ${code} - ${err ? err.stack : err}`);\n        } else {\n            this.adapter.log.debug(`${this.name}: Socket closed.`);\n        }\n        this.stop();\n        this.ready = false;\n        //abuse unused intervalHandle here.\n        if (this.intervalHandle) {\n            this.adapter.clearTimeout(this.intervalHandle);\n        }\n        this.intervalHandle = this.adapter.setTimeout(async () => {\n            await this.start();\n        }, 10000);\n    }\n\n    /**\n     * starting communication with device from config.\n     *\n     * @returns void\n     */\n    async start(): Promise<void> {\n        await super.start();\n\n        //event listener:\n        this.client.on('switched', async (val: boolean, socket: number) => {\n            this.adapter.log.debug(`Event from device ${socket} now ${val}`);\n            if (this.numSockets > 1) {\n                await this.adapter.setState(`${this.id + Suffixes.state}_${socket + 1}`, val, true);\n            } else {\n                await this.adapter.setState(this.id + Suffixes.state, val, true);\n            }\n        });\n        //error handling:\n        this.client.on('error', (code: number, error: Error) => this.onError(code, error));\n        this.client.on('close', () => this.onError());\n        this.client.on('message', (message: string) => this.adapter.log.debug(`${this.name} got message: ${message}`));\n        await this.adapter.setState(this.id + Suffixes.unreachable, false, true);\n        this.ready = true;\n        this.adapter.log.debug('Setup device event listener.');\n    }\n\n    /**\n     * process a state change. Device will just try to switch plug. Children will have to overwrite this behaviour.\n     *\n     * @param id of state that changed\n     * @param state new state\n     */\n    async handleStateChange(id: string, state: ioBroker.State): Promise<void> {\n        if (typeof state.val === 'boolean') {\n            if (!this.loggedIn) {\n                await this.login();\n            }\n\n            let socket = 0;\n            if (this.numSockets > 1) {\n                socket = Number(id.substring(id.lastIndexOf('_') + 1)) - 1; //convert to 0 based index here.\n            }\n            try {\n                const newVal = await this.client.switch(state.val, socket);\n                this.adapter.log.debug(`Switched Socket ${socket} of ${this.name} ${state.val ? 'on' : 'off'}.`);\n                await this.adapter.setState(id, newVal, true);\n            } catch (e: any) {\n                const code = processNetworkError(e);\n                if (code === 403) {\n                    this.loggedIn = false; //login next polling.\n                }\n                this.adapter.log.error(`Error while switching device ${this.name}: ${code} - ${e.stack}`);\n            }\n        } else {\n            this.adapter.log.warn('Wrong state type. Only boolean accepted for switch.');\n        }\n    }\n\n    /**\n     * Get model info of unknown devices for Sentry logging.\n     */\n    async getModelInfoForSentry(): Promise<any> {\n        const url = `http://${this.ip}/login?username=Admin&password=${this.pinDecrypted}`;\n        const result = await axios.get(url);\n        return result.data;\n    }\n\n    /**\n     * Identify device, i.e. check mac and get model.\n     */\n    async identify(): Promise<boolean> {\n        const id = this.client.getDeviceId();\n        const mac = id.match(/.{2}/g)!.join(':').toUpperCase(); //add back the :.\n\n        if (this.mac && this.mac !== mac) {\n            throw new WrongMacError(\n                `${this.name} reported mac ${mac}, expected ${this.mac}, probably ip ${this.ip} wrong and talking to wrong device?`,\n            );\n        }\n        this.mac = mac;\n        this.id = id;\n\n        //get model from webserver / wifi-ssid:\n        const url = `http://${this.ip}/login?username=Admin&password=${this.pinDecrypted}`;\n        let recievedModel = '';\n        try {\n            const result = await axios.get(url);\n            if (result.status === 200) {\n                const startPos = result.data.indexOf('SSID: ') + 6;\n                const model = result.data.substring(startPos, startPos + 8);\n                if (!model) {\n                    this.adapter.log.warn(\n                        `${this.name} identify responded with unknown result, please report: ${result.data}`,\n                    );\n                }\n                this.adapter.log.debug(`Got model ${model} during identification of ${this.name}`);\n                recievedModel = model;\n            } else {\n                this.adapter.log.warn(`${this.name} could not be identified: ${result.data}`);\n            }\n        } catch (e) {\n            const code = await this.handleNetworkError(e);\n            console.log(`Got code: ${code}`);\n            if (code === 'ECONNREFUSED') {\n                this.adapter.log.debug('Failed to identify -> for now assume W118, because that one is nasty.');\n                recievedModel = 'DSP-W118';\n            }\n        }\n\n        if (recievedModel && recievedModel !== this.model) {\n            const oldModel = this.model;\n            this.model = recievedModel;\n            this.adapter.log.info(`Model updated from ${oldModel || 'unknown'} to ${recievedModel}`);\n            throw new WrongModelError(`${this.name} model changed from ${oldModel} to ${recievedModel}`);\n        }\n\n        //make sure objects are created.\n        const superResult = await super.identify();\n\n        //get current state:\n        if (this.numSockets > 1) {\n            const states = (await this.client.state(-1)) as Array<boolean>; //get all states.\n            for (let index = 1; index <= this.numSockets; index += 1) {\n                await this.adapter.setStateChangedAsync(\n                    `${this.id + Suffixes.state}_${index}`,\n                    states[index - 1],\n                    true,\n                );\n            }\n        } else {\n            const state = (await this.client.state()) as boolean;\n            await this.adapter.setStateChangedAsync(this.id + Suffixes.state, state, true);\n        }\n\n        return superResult;\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAA4E;AAC5E,sBAAyB;AAEzB,mBAAiC;AACjC,mCAA4B;AAKrB,MAAM,wBAAwB,qBAAO;AAAA,EACxC;AAAA,EAEA,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUb,YAAY,SAAkB,IAAY,KAAa,cAAuB;AAtBlF;AAuBQ,UAAM,SAAS,IAAI,KAAK,YAAY;AACpC,SAAK,cAAc;AAEnB,SAAK,SAAS,IAAI,6BAAAA,QAAgB;AAAA,MAC9B,IAAI,KAAK;AAAA,MACT,KAAK,KAAK;AAAA,MACV,WAAW;AAAA,MACX,qBAAmB,UAAK,iBAAL,mBAAmB,mBAAkB;AAAA,MACxD,KAAK,QAAQ;AAAA,IACjB,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAA+B;AACjC,UAAM,MAAM,cAAc;AAC1B,QAAI,KAAK,aAAa,GAAG;AAErB,eAAS,QAAQ,GAAG,SAAS,KAAK,YAAY,SAAS,GAAG;AACtD,cAAM,KAAK,GAAG,KAAK,KAAK,yBAAS,KAAK,IAAI,KAAK;AAC/C,cAAM,KAAK,QAAQ,wBAAwB,IAAI;AAAA,UAC3C,MAAM;AAAA,UACN,QAAQ;AAAA,YACJ,MAAM,UAAU,KAAK;AAAA,YACrB,MAAM;AAAA,YACN,MAAM;AAAA,YACN,MAAM;AAAA,YACN,OAAO;AAAA,UACX;AAAA,UACA,QAAQ,EAAE,MAAa;AAAA,QAC3B,CAAC;AACD,cAAM,KAAK,QAAQ,qBAAqB,EAAE;AAAA,MAC9C;AAAA,IACJ,OAAO;AAEH,YAAM,KAAK,QAAQ,wBAAwB,KAAK,KAAK,yBAAS,OAAO;AAAA,QACjE,MAAM;AAAA,QACN,QAAQ;AAAA,UACJ,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,OAAO;AAAA,QACX;AAAA,QACA,QAAQ,CAAC;AAAA,MACb,CAAC;AACD,YAAM,KAAK,QAAQ,qBAAqB,KAAK,KAAK,yBAAS,KAAK;AAAA,IACpE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,OAAa;AACT,UAAM,KAAK;AACX,QAAI,KAAK,UAAU,OAAO,KAAK,OAAO,uBAAuB,YAAY;AACrE,WAAK,OAAO,mBAAmB,QAAQ;AACvC,WAAK,OAAO,mBAAmB,OAAO;AACtC,WAAK,OAAO,mBAAmB,OAAO;AACtC,WAAK,OAAO,mBAAmB,SAAS;AAAA,IAC5C;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,aAA4B;AAC9B,UAAM,MAAM,WAAW;AAEvB,QAAI,KAAK,OAAO;AACZ,UAAI;AACA,YAAI,KAAK,aAAa,GAAG;AACrB,gBAAM,SAAU,MAAM,KAAK,OAAO,MAAM,EAAE;AAC1C,mBAAS,QAAQ,GAAG,SAAS,KAAK,YAAY,SAAS,GAAG;AACtD,kBAAM,KAAK,GAAG,KAAK,KAAK,yBAAS,KAAK,IAAI,KAAK;AAC/C,kBAAM,MAAM,OAAO,QAAQ,CAAC;AAC5B,kBAAM,KAAK,QAAQ,qBAAqB,IAAI,KAAK,IAAI;AAAA,UACzD;AAAA,QACJ,OAAO;AACH,gBAAM,MAAO,MAAM,KAAK,OAAO,MAAM,CAAC;AACtC,gBAAM,KAAK,QAAQ,qBAAqB,KAAK,KAAK,yBAAS,OAAO,KAAK,IAAI;AAAA,QAC/E;AAAA,MACJ,SAAS,GAAG;AACR,cAAM,KAAK,mBAAmB,CAAC;AAAA,MACnC;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,QAAQ,MAAe,KAA4B;AACrD,UAAM,KAAK,QAAQ,SAAS,KAAK,KAAK,yBAAS,aAAa,MAAM,IAAI;AACtE,QAAI,QAAQ,KAAK;AACb,WAAK,QAAQ,IAAI,MAAM,GAAG,KAAK,IAAI,mBAAmB,IAAI,MAAM,MAAM,IAAI,QAAQ,GAAG,EAAE;AAAA,IAC3F,OAAO;AACH,WAAK,QAAQ,IAAI,MAAM,GAAG,KAAK,IAAI,kBAAkB;AAAA,IACzD;AACA,SAAK,KAAK;AACV,SAAK,QAAQ;AAEb,QAAI,KAAK,gBAAgB;AACrB,WAAK,QAAQ,aAAa,KAAK,cAAc;AAAA,IACjD;AACA,SAAK,iBAAiB,KAAK,QAAQ,WAAW,YAAY;AACtD,YAAM,KAAK,MAAM;AAAA,IACrB,GAAG,GAAK;AAAA,EACZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,QAAuB;AACzB,UAAM,MAAM,MAAM;AAGlB,SAAK,OAAO,GAAG,YAAY,OAAO,KAAc,WAAmB;AAC/D,WAAK,QAAQ,IAAI,MAAM,qBAAqB,MAAM,QAAQ,GAAG,EAAE;AAC/D,UAAI,KAAK,aAAa,GAAG;AACrB,cAAM,KAAK,QAAQ,SAAS,GAAG,KAAK,KAAK,yBAAS,KAAK,IAAI,SAAS,CAAC,IAAI,KAAK,IAAI;AAAA,MACtF,OAAO;AACH,cAAM,KAAK,QAAQ,SAAS,KAAK,KAAK,yBAAS,OAAO,KAAK,IAAI;AAAA,MACnE;AAAA,IACJ,CAAC;AAED,SAAK,OAAO,GAAG,SAAS,CAAC,MAAc,UAAiB,KAAK,QAAQ,MAAM,KAAK,CAAC;AACjF,SAAK,OAAO,GAAG,SAAS,MAAM,KAAK,QAAQ,CAAC;AAC5C,SAAK,OAAO,GAAG,WAAW,CAAC,YAAoB,KAAK,QAAQ,IAAI,MAAM,GAAG,KAAK,IAAI,iBAAiB,OAAO,EAAE,CAAC;AAC7G,UAAM,KAAK,QAAQ,SAAS,KAAK,KAAK,yBAAS,aAAa,OAAO,IAAI;AACvE,SAAK,QAAQ;AACb,SAAK,QAAQ,IAAI,MAAM,8BAA8B;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,kBAAkB,IAAY,OAAsC;AACtE,QAAI,OAAO,MAAM,QAAQ,WAAW;AAChC,UAAI,CAAC,KAAK,UAAU;AAChB,cAAM,KAAK,MAAM;AAAA,MACrB;AAEA,UAAI,SAAS;AACb,UAAI,KAAK,aAAa,GAAG;AACrB,iBAAS,OAAO,GAAG,UAAU,GAAG,YAAY,GAAG,IAAI,CAAC,CAAC,IAAI;AAAA,MAC7D;AACA,UAAI;AACA,cAAM,SAAS,MAAM,KAAK,OAAO,OAAO,MAAM,KAAK,MAAM;AACzD,aAAK,QAAQ,IAAI,MAAM,mBAAmB,MAAM,OAAO,KAAK,IAAI,IAAI,MAAM,MAAM,OAAO,KAAK,GAAG;AAC/F,cAAM,KAAK,QAAQ,SAAS,IAAI,QAAQ,IAAI;AAAA,MAChD,SAAS,GAAQ;AACb,cAAM,WAAO,mCAAoB,CAAC;AAClC,YAAI,SAAS,KAAK;AACd,eAAK,WAAW;AAAA,QACpB;AACA,aAAK,QAAQ,IAAI,MAAM,gCAAgC,KAAK,IAAI,KAAK,IAAI,MAAM,EAAE,KAAK,EAAE;AAAA,MAC5F;AAAA,IACJ,OAAO;AACH,WAAK,QAAQ,IAAI,KAAK,qDAAqD;AAAA,IAC/E;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,wBAAsC;AACxC,UAAM,MAAM,UAAU,KAAK,EAAE,kCAAkC,KAAK,YAAY;AAChF,UAAM,SAAS,MAAM,aAAAC,QAAM,IAAI,GAAG;AAClC,WAAO,OAAO;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,WAA6B;AAC/B,UAAM,KAAK,KAAK,OAAO,YAAY;AACnC,UAAM,MAAM,GAAG,MAAM,OAAO,EAAG,KAAK,GAAG,EAAE,YAAY;AAErD,QAAI,KAAK,OAAO,KAAK,QAAQ,KAAK;AAC9B,YAAM,IAAI;AAAA,QACN,GAAG,KAAK,IAAI,iBAAiB,GAAG,cAAc,KAAK,GAAG,iBAAiB,KAAK,EAAE;AAAA,MAClF;AAAA,IACJ;AACA,SAAK,MAAM;AACX,SAAK,KAAK;AAGV,UAAM,MAAM,UAAU,KAAK,EAAE,kCAAkC,KAAK,YAAY;AAChF,QAAI,gBAAgB;AACpB,QAAI;AACA,YAAM,SAAS,MAAM,aAAAA,QAAM,IAAI,GAAG;AAClC,UAAI,OAAO,WAAW,KAAK;AACvB,cAAM,WAAW,OAAO,KAAK,QAAQ,QAAQ,IAAI;AACjD,cAAM,QAAQ,OAAO,KAAK,UAAU,UAAU,WAAW,CAAC;AAC1D,YAAI,CAAC,OAAO;AACR,eAAK,QAAQ,IAAI;AAAA,YACb,GAAG,KAAK,IAAI,2DAA2D,OAAO,IAAI;AAAA,UACtF;AAAA,QACJ;AACA,aAAK,QAAQ,IAAI,MAAM,aAAa,KAAK,6BAA6B,KAAK,IAAI,EAAE;AACjF,wBAAgB;AAAA,MACpB,OAAO;AACH,aAAK,QAAQ,IAAI,KAAK,GAAG,KAAK,IAAI,6BAA6B,OAAO,IAAI,EAAE;AAAA,MAChF;AAAA,IACJ,SAAS,GAAG;AACR,YAAM,OAAO,MAAM,KAAK,mBAAmB,CAAC;AAC5C,cAAQ,IAAI,aAAa,IAAI,EAAE;AAC/B,UAAI,SAAS,gBAAgB;AACzB,aAAK,QAAQ,IAAI,MAAM,uEAAuE;AAC9F,wBAAgB;AAAA,MACpB;AAAA,IACJ;AAEA,QAAI,iBAAiB,kBAAkB,KAAK,OAAO;AAC/C,YAAM,WAAW,KAAK;AACtB,WAAK,QAAQ;AACb,WAAK,QAAQ,IAAI,KAAK,sBAAsB,YAAY,SAAS,OAAO,aAAa,EAAE;AACvF,YAAM,IAAI,8BAAgB,GAAG,KAAK,IAAI,uBAAuB,QAAQ,OAAO,aAAa,EAAE;AAAA,IAC/F;AAGA,UAAM,cAAc,MAAM,MAAM,SAAS;AAGzC,QAAI,KAAK,aAAa,GAAG;AACrB,YAAM,SAAU,MAAM,KAAK,OAAO,MAAM,EAAE;AAC1C,eAAS,QAAQ,GAAG,SAAS,KAAK,YAAY,SAAS,GAAG;AACtD,cAAM,KAAK,QAAQ;AAAA,UACf,GAAG,KAAK,KAAK,yBAAS,KAAK,IAAI,KAAK;AAAA,UACpC,OAAO,QAAQ,CAAC;AAAA,UAChB;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,OAAO;AACH,YAAM,QAAS,MAAM,KAAK,OAAO,MAAM;AACvC,YAAM,KAAK,QAAQ,qBAAqB,KAAK,KAAK,yBAAS,OAAO,OAAO,IAAI;AAAA,IACjF;AAEA,WAAO;AAAA,EACX;AACJ;",
  "names": ["WebSocketClient", "axios"]
}
